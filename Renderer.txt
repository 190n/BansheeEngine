Make MeshProxy also be CPU based?
 - Signal when bounds change from CoreThreadAccessor
    - add preWriteCallback that's called on CPU to GpuResource
 - Remove a list of RenderableProxies from MeshRenderData
 - Renderable can check if it is dirty

Make RenderableProxy -> CoreProxy, move it to Renderable and make it a shared pointer (maybe an unique pointer?)
 - This solves the issue with not knowing when to delete RenderableProxies

Need a way to update existing material proxies when params change
 - Create bindable GPu params, pass them to core and update GpuParams

Apply world view proj matrix in renderer

Stage 2:
Add material <-> renderer interface matching
 - Ensure renderer creates and updates parameters and parameter blocks it owns
 - Actually add frustum culling
 - Implement RenderQueue sorting with support for sort type, priority and separable pass
   - Use a hash list(containing type, queue, layer, etc.) for faster sorting

Finally
 - Document elements marked with TODO UNDOCUMENTED
 - Refactor/rename everything so it makes more sense. Possibly lay out a design diagram.
 - Get rid of Camera::getIgnoreSceneRenderables it can be doing using layers
 - Delete RenderOperation as I don't think I use it anymore

Semantic/design issues:
 - DrawList is too similar to RenderQueue - Their names need to be more distinct
 - MeshProxy is very different that material/camera/renderable proxy. Rename it to something else?
 - Material and camera proxy is returned by value while renderable by pointer. Also material proxy seems a bit heavy weight to be passed by value.
 - Consider removing SceneManager from Core? I two scene manager base classes.
 - Consider moving RenderOperation in RenderQueue and removing its header/source. Maybe also renaming it to something more render queue specific. 
 - Remove DefaultRenderQueue. Instead make RenderQueue non-abstract and have it provide default implementation.


-------------------------------------------------------
ENSURING MATERIAL COMPATIBILITY:

When renderer is first created we create a list of default materials, each corresponding to a single valid renderable type.
When checking for material compatibility we compare parameter and param block descriptions between example
and material we're comparing. This way I don't even have to check if shader has param block or not, I already
know from the example material.

When material proxy is bound to the renderer matching parameters are found, and the renderer will take care of filling them out.
 - If example material uses a param block but current material doesn't, even if parameters match we won't update them from renderer.
 - Material proxy will be updated with a helper structure describing the renderable type the material is created with
    - It will contain values representing which semantics are active
	- And pointers to those semantics buffers and param handles

---------------------------

Just notes for later potentially:
 - I can only update entire Mesh at once. 
 - I keep bounds for the entire mesh and not per-submesh
 - I don't serialize bounds and they are recalculated whenever a mesh is loaded