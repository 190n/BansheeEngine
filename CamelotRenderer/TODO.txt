
-----------------------LONGTERM TODO----------------------------------------------------------------
 - Debug tools 
   - Camera controls + world grid
 - Renderable (contains mesh/material)
 - RenderManager (iterated through Renderables and displays them on screen)
   - And its plugin implementation ForwardRenderingManager
 - Integrate with Camelot Editor
 - SceneManager plugin
   - Frustum culling and octree (or some other) acceleration structure
   - Render queue and sorting

-----------------------IMMEDIATE TODO---------------------------------------------------------------

Plan until end of February:
Week A:
 Generic buffers DX11 and dummy implementations (that log warnings) for DX9 and OpenGL
 Texture buffers in DX11 and OpenGL
 A way to bind buffers to a Pass, while specifying buffer range

Week B:
 Stream out (mainly OpenGL)
 Static/Dynamic usage for GpuParamBlocks
 GpuParams support for bools, buffers, structs

Week C:
 Refactor render system methods to comply with DX11
 Implement working DX11 render system Part 1

Week D:
 Implement working DX11 render system Part 2

Week E:
 Refactor so that primary window is created with rendersystem initialization
 Make RenderTexture and DepthStenciLTexture use common interface

Week F:
 Ability to switch out GpuParamBlocks
 Smart way of initializing GpuParamBlocks (without duplicates)
 Port CG so it no longer uses low level shaders
 Fix MaterialRTTI saving (Save params per gpuprogram is simplest and cleanest)
 Make sure that gpu programs assigned to Pass don't share parameters of different types

Week G:
 Refactor how we handle RenderTargets (no attach/detach, and no waitForVSync propery in RenderSystem)
 Fix how and when is GpuParamBlock created/destroyed. Needs to happen on the render thread

>>>>>>>>>>>>>>>START WORKING ON THE EDITOR!
 



/////
-----------GpuProgramParameters/Pass/Material REFACTOR------------------------------

Destroying and constructing GpuParamBlock happens on main thread, which is wrong (especially destroying it)

Saving/loading of material params isn't completed (in MAterialRTTI)
Port DX11 to new shader param system
Ability to switch out GpuParamBlocks (i.e. share them between programs)
Ability to create Pass without automatically creating param blocks
Automatically creating a pass should be smart about not creating duplicate param blocks
Port CG so it doesn't attempt to use low level GL shaders (which I have removed)

Handling of array parameters? This needs testing
 - I'm currently ignoring array elements in GL due to the name their names are handled


---------------------------------------------------

monitorIndex is ignored in DX11

Creating a primary window and initializing the render system should probably be one step
 - OpenGL requires it anyway in order to get context (Make sure to update GLRenderWindowManager if I change how this works)
 - I can't imagine much use for a render system without a window. (Windowless client is a possibility, but in that case entire render system would not be needed)
 - And if just rendering to texture (or similar) is needed, a hidden window may be used

Don't forget to check out Unity DX11 documentation on how to implement DX11 features (http://docs.unity3d.com/Documentation/Manual/DirectX11.html)

Unity has a common class for both RenderTexture and DepthStencilBuffer
 - Maybe rename DepthStencilBuffer to DepthStencilTexture?

waitForVsync can probably be moved somewhere other than being directly in RenderSystem? (where is it in DX11?)

Keeping a list of all render targets in RenderSystem shouldn't be needed (and calling attach/detach renderTarget). Renderer should determine in what order are render targets presented.

Make CommandQueue not use mutexes and use atomics instead??
Make sure that the simulation can't run faster then the render thread! (Block the main thread until previous render finishes)
Figure out how to handle accessing texture from a non-render thread?

Issue of setting individual parameters on a material
 - Material can contain multiple techniques
 - How do I ensure parameters are valid for all techniques?
 - Require user to create a Material parameter specification?
 - Also need a way to avoid displaying internal parameters used by the active renderer
/////



RenderSystem needed modifications
 - High priority
  - Figure out how to handle different resource views and setting them on Passes
    - Specifying buffer & texture ranges
	- Setting UAV for both buffers and textures (Need to add a special flag for texture creation)
  - Generic buffers (Normal/Structured/Raw/Append/Consume/Indirect)
  - Texture buffers 
   - Just add a special texture type? OpenGL doesn't support getting offset from within a texture buffer anyway
  - Stream out (write vertex buffers) (DX11 and GL)
  - Static/Dynamic usage for GpuParamBlocks
  - GpuParams need to support bools, buffers & structs (void*)
  - Tesselation (hull/domain) shader
  - Detachable and readable depthstencil buffer (Window buffers not required as they behave a bit differently in OpenGL)
   - Also make DepthStencilBuffer share common features with RenderTexture
  
 - Low priority
  - OpenGL provides image load/store which seems to be GL UAV equivalent (http://www.opengl.org/wiki/Image_Load_Store)
  - Resolving MSAA textures (i.e. copying them to non-MSAA so they can be displayed on-screen). DX has ResolveSubresource, and OpenGL might have something similar.
  - Single and dual channel textures (especially render textures, which are very important for effects like SSAO)
  - Compute pipeline
  - Instancing (DrawInstanced) (DX11 and GL)
  - OpenGL append/consume buffers
  - Indirect drawing via indirect argument buffers
  - Texture arrays
  - Rendertargets that aren't just 2D (Volumetric (3D) render targets in particular)
  - Shader support for doubles
  - Dynamic shader linkage (Interfaces and similar)
  - Multisampled texture resources
  - Multiple adapters (multi gpu)
  - HLSL9/HLSL11/GLSL/Cg shaders need preprocessor defines & includes




Command buffer TODO:
 - When importing a resource, and registering it with Resources I don't think it properly gets added to the loaded resources array? For some reason shaders get created twice.
 - Doing setPixels_async in the texture doesn't make sure that the user doesn't actually modify the provided PixelData after
    that call.
 - In general I need to rethink how to handle modifying resources with multithreading

Mesh
 - Make sure to queue up mesh deletion to make sure it gets destroyed on the render thread

Make initialize & initialize_internal protected?
 - Only their factories and RTTI classes need to access it (and they can be friends)
 - Would need to modify HighLevelGpuProgram::mAssemblerProgram

When saving a resource, make sure resource is properly loaded before saving
  - Add doc to Resources::save that says it will block until render thread updates the resource
  - Add documentation that tells the user that reading a resource non-async will block the thread and execute all queued render commands first
  - Remove Response handlers from Resources

-----------------------BACKLOG TODO---------------------------------------------------------------

HIGH PRIORITY TODO:
 - Issue with deserialization and value types:
  - Value types are only set at the end of deserialization, because I want to be sure all of their fields are initialized. However there is nothing stopping a custom RTTI method from accessing a (yet uninitialized) value in a ptr field. (See CmMaterialRTTI, setTexParam). I need to initialize fields in a better order.
   - Solution?: Set (empty) ptr values immediately, and only load them later
 - GetRenderOperation doesn't consider sub-meshes

Mid priority TODO:
 - Resource handle should store a unique integer ID, which just points to a table of GUIDs. Keeping GUID string everywhere in not efficient.
 - Add a field that tracks % of resource deserialization in BinarySerializer
 - Mesh loading:
  - Example Freefall mesh has one index per vertex, and there are 17k+ vertices. I think I need a post-process step that optimizes them.
  - Imported FBX meshes are too big
  - Search for all remaining "TODO PORT" comments and fix them
  - Ogre performed special DDS loading. I removed that. I'm not sure if I'll need to re-add it?
  - My log is not thread safe yet it is being called from multiple threads.
 - RTTI:
     When defining RTTIType like so: 
      RTTIType<D3D9HLSLProgram, HighLevelGpuProgram, D3D9HLSLProgramRTTI>
     I need to make sure that HighLevelGpuProgram class has valid RTTI type as well. Otherwise the inheritance hierarchy will not be correct. Right now this isn't checked anywhere.

Low priority TODO:
 - Can I assign a RenderTexture to a Pass?
 - Mesh loading:
  - Sub-meshes aren't being transformed by world matrices of their nodes
 - Are resource getting properly unloaded? e.g. when shared_ptr destroys a texture is it removed from gpu?
  - Make sure resources only get properly unloaded at end of every frame. This is because a lot of RenderSystem stuff holds raw ptrs
	to resources, and it keeps them throughout the frame (especially with deferred rendering). Plus this can only be done on the render thread anyway.
 - Remove template from RTTIType and move it to IReflectable? This way i can hopefully move GetRTTITypeStatic and GetRTTIType to IReflectable so I don't
   need to manually implement those for every method.
 - Viewport needs to be updated when I call RenderTarget::setFullscreen/finishSwitchingFullscreen/updateWindowRect/windowMovedOrResized. Currently it's not
 - D3D9Texture::createTextureResources is commented out at the moment. It gets called on device reset, and at that point I should reload texture resources.
  - I should probably keep all resources by DX managed. OpenGL apparently keeps a mirror of all its resources anyway.
 - Device reset and resource re-loading in general
 - In RTTIType it is possible to add a non-plain data type using addPlainField. This can cause memory corruption issues
   if pointer is saved/loaded as a plain field. I need to add a check that ensures the type is POD. 
   See: http://www.boost.org/doc/libs/1_51_0/boost/mpi/datatype.hpp for a possible implementation of a compile time check.
 - Fix up WorkQueue as it doesn't lock when initializing, to make sure threads are actually started before returning
 - DepthStencilBuffer & Texture should possibly share the same interface instead of being two separate classes? I'll need to assign DepthStencil to shaders sometimes. Not possible in DX9 but possible in DX11.
 - CPU reading or writing to a render texture in OpenGL is not supported. (CmGLHardwarePixelBuffer::upload/download). 

Optional TODO:
 - Add precompiled headers to all projects
 - If possible, make sure GLSL uses EntryPoint and Profile fields I have added to GpuProgram
 - Move all x86 libs to x86 folders. Move all binaries to x86 folders as well
 - Serializable callbacks can't be null otherwise compiler complains
 - FBX importer can be greatly sped up by implementing a better allocator
 - Extend texture copy so it accepts different subregions & subresources (currently only entire resource can be copied)
 - Need a way to convert MSAA render texture into a normal render texture

 -----------------------------------------------------------------------------------------------

After everything is polished
 - Each view (i.e. camera) of the scene should be put into its own thread
 - How do I handle multiple mesh formats? Some files need animation, other don't. Some would mabye like to use QTangent, others the proper tangent frame.
  - Asset postprocessor? Imports a regular mesh using normal importers and then postprocesses it into a specialized format?
 - Load texture mips separately so we can unload HQ textures from far away objects (like UE3)
 - Add Unified shader so I can easily switch between HLSL and GLSL shaders (they need same parameters usually, just different code)
    - Maybe just add support for Cg and force everyone to use that? - I'd like to be able to just switch out renderer in a single location and that everything keeps on working without 
	  further modifications.
 - Port boost threads to std threads (CmThreadDefines.h)
 - Remove HardwarePixelBuffer (DX11 doesn't use it, and DX9 and OpenGL textures can be rewritten so they have its methods internally)
 - Multihead device
 - 3D rendering (use low level hardware methods for it)
 
 - Go to Game Engine Architecture book and make a list of Utility systems we will need (Config files, Parsers, File I/O etc)
 - Go to GEA book and read about resource managers before implementing them
   - Actually I should re-read most of the chapers in the book, or all of it

 - OpenGL non-Win32 window files haven't been properly parsed or tested
   - Since I probably can't compile them, try adding them to VS and see what intellisense says?

 - Textures and all other buffers keep a copy of their data in system memory. If there are memory constraints we might need a way to avoid this.

