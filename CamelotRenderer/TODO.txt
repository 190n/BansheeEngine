
High-level TODO:
 - Debug tools 
   - Camera controls + world grid
 - Renderable (contains mesh/material)
 - RenderManager (iterated through Renderables and displays them on screen)
   - And its plugin implementation ForwardRenderingManager
 - Material/Pass
 - Resource loading thread safety and background loading
   - Make sure all resources have default resource that will be used before actual resource is loaded
 - Integrate with Camelot Editor
 - SceneManager plugin
   - Frustum culling and octree (or some other) acceleration structure
   - Render queue and sorting
 - DX11 render system


Command buffer TODO:
 Immediate:
 - Rename ResourceRef to ResourceHandle?
 - setVertexDeclaration/setVertexBufferBinding still need their deferred versions
 - schedule startUp to happen on render thread
   - do the same in OpenGL
 - surround the thread checks with #if _DEBUG

MAYBE:
 - Create DeferredRenderSystem class that has exactly the same public interface as RenderSystem, but defers all calls to a command buffer
   - As its methods are called we can also filter out values that exactly match the previous ones and minimize number of state changes
      (Although this should probably be on a higher level, because 1 class 1 use)

RESOURCE COMMANDS!!:
 - They get queued up into the RenderSystem same like render commands
 - They handle all resource creation/updates/destroy
 - They are high level:
   - i.e. CmndInitializeTexture - contains Texture to initialize and data to initialize it with
 - This allows makes it possible not to store temporary texture or mesh data in the texture/mesh objects between initialization. The data is stored with the command instead.
 - Also we don't need to handle resource loading in two steps. After loading is complete, resource gets queued up and initialized before next render frame.
 - Make sure to clearly separate CPU and GPU commands on resources. Tell the user that GPU commands are deferred and will only be executed later. (Provide option to let him choose?)

Essential TODO for deferred rendering:
 - Block all calls to RenderSystem outside of Render thread (or at least warn)
 - Prevent user from accessing vertex/index buffers and similar outside of render thread as well (e.g. GpuProgram, Texture)

 - Modify resource creation so it calls RenderContext and just schedules resource creation

 - Figure out how to handle reading of resources properly



HIGH PRIORITY TODO:
 - Issue with deserialization and value types:
  - Value types are only set at the end of deserialization, because I want to be sure all of their fields are initialized. However there is nothing stopping a custom RTTI method from accessing a (yet uninitialized) value in a ptr field. (See CmMaterialRTTI, setTexParam). I need to initialize fields in a better order.
   - Solution?: Set (empty) ptr values immediately, and only load them later
 - GetRenderOperation doesn't consider sub-meshes
 - HLSL & Cg don't handle include files yet

Mid priority TODO:
 - Add a field that tracks % of resource deserialization in BinarySerializer

 - Separate render thread
   - CommandBuffer (technically it should be just a RenderQueue I think)
   - Main thread updates components, finds visible meshes and creates render device. At end of execution it fills up render queue
   - Render thread renders everything in the render queue, and also creates resources (although RenderQueue name doesn't make sense if its used for resources too)
   - Before I start with this I should probably strip down render system to a bare minimum

 - GpuProgram default parameters might not be needed. The parameters change with each use of the gpu program anyway
 - Mesh loading:
  - Example Freefall mesh has one index per vertex, and there are 17k+ vertices. I think I need a post-process step that optimizes them.
  - Imported FBX meshes are too big
  - Search for all remaining "TODO PORT" comments and fix them
  - How do I serialize derived classes, without rewriting all the base class serialization?
  - Ogre performed special DDS loading. I removed that. I'm not sure if I'll need to re-add it?
 - RTTI:
     When defining RTTIType like so: 
      RTTIType<D3D9HLSLProgram, HighLevelGpuProgram, D3D9HLSLProgramRTTI>
     I need to make sure that HighLevelGpuProgram class has valid RTTI type as well. Otherwise the inheritance hierarchy will not be correct. Right now this isn't checked anywhere.

Low priority TODO:
 - Mesh loading:
  - Sub-meshes aren't being transformed by world matrices of their nodes
  - FBX importer can be greatly sped up by implementing a better allocator
 - Serializable callbacks can't be null otherwise compiler complains
 - Depth test is disabled by default (OpenGL renderer at least)
 - Are resource getting properly unloaded? e.g. when shared_ptr destroys a texture is it removed from gpu?
  - Make sure resources only get properly unloaded at end of every frame. This is because a lot of RenderSystem stuff holds raw ptrs
	to resources, and it keeps them throughout the frame (especially with deferred rendering). Plus this can only be done on the render thread anyway.
 - Remove template from RTTIType and move it to IReflectable? This way i can hopefully move GetRTTITypeStatic and GetRTTIType to IReflectable so I don't
   need to manually implement those for every method.
 - Viewport needs to be updated when I call RenderTarget::setFullscreen/finishSwitchingFullscreen/updateWindowRect/windowMovedOrResized. Currently it's not
 - D3D9Texture::createTextureResources is commented out at the moment. It gets called on device reset, and at that point I should reload texture resources.
  - I should probably keep all resources by DX managed. OpenGL apparently keeps a mirror of all its resources anyway.
 - Device reset and resource re-loading in general
 - In RTTIType it is possible to add a non-plain data type using addPlainField. This can cause memory corruption issues
   if pointer is saved/loaded as a plain field. I need to add a check that ensures the type is POD. 
   See: http://www.boost.org/doc/libs/1_51_0/boost/mpi/datatype.hpp for a possible implementation of a compile time check.
 - Fix up WorkQueue as it doesn't lock when initializing, to make sure threads are actually started before returning
 
Optional TODO:
 - Add precompiled headers to all projects
 - If possible, make sure GLSL uses EntryPoint and Profile fields I have added to GpuProgram

 -----------------------------------------------------------------------------------------------

After everything is polished:
 - Make sure the renderer can run on a separate thread
  - Command buffers that allow dx9, dx11 and opengl all use a separate render thread
 - Load texture mips separately so we can unload HQ textures from far away objects (like UE3)
 - Get 64bit version working
 - Add Unified shader so I can easily switch between HLSL and GLSL shaders (they need same parameters usually, just different code)
    - Maybe just add support for Cg and force everyone to use that? - I'd like to be able to just switch out renderer in a single location and that everything keeps on working without 
	  further modifications.
 - Port boost threads to std threads (CmThreadDefines.h)
 
 - Go to Game Engine Architecture book and make a list of Utility systems we will need (Config files, Parsers, File I/O etc)
 - Go to GEA book and read about resource managers before implementing them
   - Actually I should re-read most of the chapers in the book, or all of it

 - OpenGL non-Win32 window files haven't been properly parsed or tested
   - Since I probably can't compile them, try adding them to VS and see what intellisense says?

 - Textures and all other buffers keep a copy of their data in system memory. If there are memory constraints we might need a way to avoid this.

