
-----------------------LONGTERM TODO----------------------------------------------------------------
 - Debug tools 
   - Camera controls + world grid
 - Renderable (contains mesh/material)
 - RenderManager (iterated through Renderables and displays them on screen)
   - And its plugin implementation ForwardRenderingManager
 - Integrate with Camelot Editor
 - SceneManager plugin
   - Frustum culling and octree (or some other) acceleration structure
   - Render queue and sorting

-----------------------IMMEDIATE TODO---------------------------------------------------------------





/////
Check out how to deal with clip planes so that both DX9, DX11 and GL support them
waitForVsync can probably be moved somewhere other than being directly in RenderSystem? (where is it in DX11?)

Move createRenderTexture to TextureManager? (also createMultiRenderTexture)
 - Right now its created with a special texture usage flag, which I don't like
Drop OpenGL support for low level shaders? (See if cg can translate to GLSL)

Make RenderSystem a module? (Initialize it using startUp, and get rid of directly accessing RenderSystemManager whenever I need the active RenderSystem)

Keeping a list of all render targets in RenderSystem shouldn't be needed (and calling attach/detach renderTarget). Renderer should determine in what order are render targets presented.

Make CommandQueue not use mutexes and use atomics instead??
Make sure that the simulation can't run faster then the render thread! (Block the main thread until previous render finishes)
/////






RenderSystem needed modifications
 - Right now HLSL11 CANNOT SPECIFY TEXTURE PARAMETERS! (Pass needs to be extended)
 - Generic buffers (Normal/Structured/Raw/Append/Consume/Indirect)
 - Ability to bind buffers and texture with different type of view (SHADER_RESOURCE & UNORDERED_ACCESS primarily, major others too)
 - Pass needs to be modified
  - Needs to support bool/double/texture1D/textue3D/textureCUBE/texture arrays/MS textures/all types of buffers/structs
 - TextureBuffer support? (Use for bones when skinning for exaple, as constant buffers are too slow)
 - RW buffers?
 - Tesselation (hull/domain) shader
 - Compute pipeline
 - Stream out (write vertex buffers)
 - Instancing
 - Dynamic shader linkage (Interfaces and similar)
 - Append/Consume buffer
 - 1D/2D/Cube texture arrays
 - Multisampled texture resources
 - Multiple adapters (multi gpu)
 - Process OpenGL and make sure to equivalents of DX11 features
  - Exact features that are missing (not an exhaustive list):
    - Vertex buffer stream out (Transform Feedback)
	- GL constant buffers
	- HLSL11 shader equivalents (domain/hull/compute shaders), and advanced shader parameters
 - HLSL9/HLSL11/GLSL/Cg shaders need preprocessor defines & includes

 RenderSystem modifications, yet another list:
   - DepthStencilView & RenderTargetView are automatically created for any RenderTarget (no special mechanism for setting them needed)

   - Extend pass with "struct" (void*) parameters to that they can be assigned to constant buffers
   - Extend pass so it accepts "GenericBuffers"

   - Add support for "GenericBuffers" (normal/structured/raw/append/consume/indirect)
   - Add support for texture buffer

   - Ability to set vertex buffer as a stream output buffer (also added to Pass)

   - Set viewport & scissor rect to rasterizer (should probably be part of RenderTarget. If so, modify DX9 and GL so they act the same)

   - Ability to create & assign unordered access views to OM and CS stages. (Extend pass and HardwareBufferManager)

   - Extend render system with DrawInstanced (Also with DrawIndirect?)

   - (Separate Pass parameters so that they are accepted per GpuProgramType, instead of using a global name?)

Command buffer TODO:
 - When importing a resource, and registering it with Resources I don't think it properly gets added to the loaded resources array? For some reason shaders get created twice.
 - My current approach doesn't allow multiple threads to use the RenderSystem (contexts should be handled differently)
   - Instead of requiring the user to constantly call setActiveContext, make the call peristent per thread. 
   - Store sequential thread idx in local thread storage, and then we can easily look up a context for a thread and
     automatically use it, if it's set. (Use boost::thread_specific_ptr for local thread storage)
 - Make sure to allow the user to submit the context manually to the gpu. (Right now all contexts are submitted at once, and when I'll have compute
 shaders running I'm sure I'll want other threads to do different things on the gpu)
 - Doing setPixels_async in the texture doesn't make sure that the user doesn't actually modify the provided PixelData after
    that call.

Mesh
 - Make sure to queue up mesh deletion to make sure it gets destroyed on the render thread

GpuProgram/HighLevelGpuProgram
 - Do a pass of refactoring
 - Fix it up for multithreading
  - In general everything needs to be checked
  - Add thread checks

Make initialize & initialize_internal protected?
 - Only their factories and RTTI classes need to access it (and they can be friends)
 - Would need to modify HighLevelGpuProgram::mAssemblerProgram

When saving a resource, make sure resource is properly loaded before saving
  - Add doc to Resources::save that says it will block until render thread updates the resource
  - Add documentation that tells the user that reading a resource non-async will block the thread and execute all queued render commands first
  - Remove Response handlers from Resources

-----------------------BACKLOG TODO---------------------------------------------------------------

HIGH PRIORITY TODO:
 - Issue with deserialization and value types:
  - Value types are only set at the end of deserialization, because I want to be sure all of their fields are initialized. However there is nothing stopping a custom RTTI method from accessing a (yet uninitialized) value in a ptr field. (See CmMaterialRTTI, setTexParam). I need to initialize fields in a better order.
   - Solution?: Set (empty) ptr values immediately, and only load them later
 - GetRenderOperation doesn't consider sub-meshes

Mid priority TODO:
 - Add multithreaded version of RenderTarget::getCustomAttribute_internal
 - Compiler2Pass in GL renderer doesn't seem to be 64bit ready. I hacked it together but it will likely cause problems.
 - Resource handle should store a unique integer ID, which just points to a table of GUIDs. Keeping GUID string everywhere in not efficient.
 - Add a field that tracks % of resource deserialization in BinarySerializer
 - GpuProgram default parameters might not be needed. The parameters change with each use of the gpu program anyway
 - Mesh loading:
  - Example Freefall mesh has one index per vertex, and there are 17k+ vertices. I think I need a post-process step that optimizes them.
  - Imported FBX meshes are too big
  - Search for all remaining "TODO PORT" comments and fix them
  - Ogre performed special DDS loading. I removed that. I'm not sure if I'll need to re-add it?
  - My log is not thread safe yet it is being called from multiple threads.
 - RTTI:
     When defining RTTIType like so: 
      RTTIType<D3D9HLSLProgram, HighLevelGpuProgram, D3D9HLSLProgramRTTI>
     I need to make sure that HighLevelGpuProgram class has valid RTTI type as well. Otherwise the inheritance hierarchy will not be correct. Right now this isn't checked anywhere.

Low priority TODO:
 - Mesh loading:
  - Sub-meshes aren't being transformed by world matrices of their nodes
 - Are resource getting properly unloaded? e.g. when shared_ptr destroys a texture is it removed from gpu?
  - Make sure resources only get properly unloaded at end of every frame. This is because a lot of RenderSystem stuff holds raw ptrs
	to resources, and it keeps them throughout the frame (especially with deferred rendering). Plus this can only be done on the render thread anyway.
 - Remove template from RTTIType and move it to IReflectable? This way i can hopefully move GetRTTITypeStatic and GetRTTIType to IReflectable so I don't
   need to manually implement those for every method.
 - Viewport needs to be updated when I call RenderTarget::setFullscreen/finishSwitchingFullscreen/updateWindowRect/windowMovedOrResized. Currently it's not
 - D3D9Texture::createTextureResources is commented out at the moment. It gets called on device reset, and at that point I should reload texture resources.
  - I should probably keep all resources by DX managed. OpenGL apparently keeps a mirror of all its resources anyway.
 - Device reset and resource re-loading in general
 - In RTTIType it is possible to add a non-plain data type using addPlainField. This can cause memory corruption issues
   if pointer is saved/loaded as a plain field. I need to add a check that ensures the type is POD. 
   See: http://www.boost.org/doc/libs/1_51_0/boost/mpi/datatype.hpp for a possible implementation of a compile time check.
 - Fix up WorkQueue as it doesn't lock when initializing, to make sure threads are actually started before returning
 - D3D9HLSLProgram stuff that isn't used (it needs to be initialized before initializing the shader, which currently isn't possible). Maybe adding it to HighLevelGpuProgramFactory?
     - setPreprocessorDefines, setColumnMajorMatrices, setOptimisationLevel

Optional TODO:
 - Add precompiled headers to all projects
 - If possible, make sure GLSL uses EntryPoint and Profile fields I have added to GpuProgram
 - Move all x86 libs to x86 folders. Move all binaries to x86 folders as well
 - Drop support for assembly shaders?
 - Shared shader parameters (Since there will be values that are constant between all Draw call it doesn't make sense to set them every call?)
 - Serializable callbacks can't be null otherwise compiler complains
 - FBX importer can be greatly sped up by implementing a better allocator

 -----------------------------------------------------------------------------------------------

After everything is polished
 - Each view (i.e. camera) of the scene should be put into its own thread
 - How do I handle multiple mesh formats? Some files need animation, other don't. Some would mabye like to use QTangent, others the proper tangent frame.
 - Load texture mips separately so we can unload HQ textures from far away objects (like UE3)
 - Add Unified shader so I can easily switch between HLSL and GLSL shaders (they need same parameters usually, just different code)
    - Maybe just add support for Cg and force everyone to use that? - I'd like to be able to just switch out renderer in a single location and that everything keeps on working without 
	  further modifications.
 - Port boost threads to std threads (CmThreadDefines.h)
 
 - Go to Game Engine Architecture book and make a list of Utility systems we will need (Config files, Parsers, File I/O etc)
 - Go to GEA book and read about resource managers before implementing them
   - Actually I should re-read most of the chapers in the book, or all of it

 - OpenGL non-Win32 window files haven't been properly parsed or tested
   - Since I probably can't compile them, try adding them to VS and see what intellisense says?

 - Textures and all other buffers keep a copy of their data in system memory. If there are memory constraints we might need a way to avoid this.

