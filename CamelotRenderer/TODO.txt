PARSED FILES:

GpuProgram - PARSED!
TextureState - PARSED!
 - This is just an utility class representing texture state
HardwareVertexBuffer - PARSED!
Viewport - PARSED!
HardwareBufferManager - PARSED!
HighLevelGpuProgram - PARSED!
VertexIndexData - Just data structures
 - VertexCacheProfiler is a weird one, but I think I don't have to remove it as it might come in handy
RenderTexture - Everything OK
RenderWindow - Everything OK
HardwareIndexBuffer - Everything OK
RenderSystemCapabilities - I think I need all of that
HardwareBuffer - Base class for all buffers
 - Everything seems fine although I /might/ want to explore how the shadow buffer works and if I want to implement it differently?
DefaultHardwareBufferManager - Provides emulation of hardware buffers
 - I think this class is okay to stay, although I'm not sure where its used, but its simple enough
Texture - PARSED!
HardwareOcclusionQuery - OK, but I might consider a more generic interface for queries (I'll need profiling queries too for example)

TODO FILES:

Camera - MERGE WITH VIEWPORT
 - Position/rotation should be inherit from transform

Frustum
 - World space methods need to be updated. I still need them but they need to get their data from Transform
 - Depending on how I implement the frustum, I might be able to remove those "out-of-date" checks

GpuProgramParams - Holds all parameters used in a shader program and allows us to set them by index or name
 - Explore if we can remove GpuSharedParameters. I'm not exactly sure what they're used for

HardwarePixelBuffer 
 - I might consider giving PixelBox a better name. Also rename PixelFormat.h to PixelUtil.h or similar. Makes more sense.
 - _clearSliceRTT method I'm not sure what is it used for, but I might want to remove it

RenderTarget:
 - update() causes rendering to start - This probably need to be moved to camera, as I want it to be responsible for rendering
 - keeps a viewport list, which I also don't think I'll need

TODO:
 - Make sure to parse D3D9 implementations of above classes and see what needs removing there as well
 - OpenGL too

TOMORROW:
 - How do I serialize derived classes, without rewriting all the base class serialization?
   - Unless something better dawns on me by Monday, just inherit from parents SerializableType and manually make sure no IDs overlap.
     - We can improve later if needed. I though about it too much for now.
 - How do I deserialize binary data without knowing what type of class (i.e. Resource) is it?
  - Each Resource (i.e. Texture, Mesh) needs to have its own manager, which then hooks into the global Resources class
  - When saving resources, save an unique resource identifier
  - Then we can call individual resource manager and it can create proper resource based on active render system and whatever else
TextureData
 - When serializing this texture, request data from GPU, populate TextureData array and return
Texture
 - Gets initialized by calling SetData(vector<TextureData). 
 - Returns TextureData by GetData (retrieves data from GPU)
 Continue working on Importer, Resources (IMPORTANT - AssetDatabase in a single file probably won't work. Multiple people won't be able to work on it. Unless we make it part of a local cache?)
 Try to fully implement free image and maybe FBX importers
  - Less important notes:
    - All of this must be thread safe to allow for background loading
    - Make sure all resources have default resource that will be used before actual resource is loaded
 - Add precompiled headers to all projects
 - Make sure they include Exception & Log classes

Other notes:
 - Search for all remaining "TODO PORT" comments and fix them
 - How am I notified on device reset? (When I need to reload my resources)
 - D3D9Texture::createTextureResources is commented out at the moment. It gets called on device reset, and at that point
     I should reload texture resources.
 - If possible, make sure GLSL uses EntryPoint and Profile fields I have added to GpuProgram
 - Remove all fixed pipeline methods from D3D9 and OpenGL renderers
 - Make CamelotRenderer a project on its own?

 At one point rebuild everything and make sure all warnings are gone
  - Also scan everything for "Ogre" and remove any references to it

After everything is polished:
 - Make sure the renderer can run on a separate thread
 - Get 64bit version working
 - Add Unified shader so I can easily switch between HLSL and GLSL shaders (they need same parameters usually, just different code)
    - Maybe just add support for Cg and force everyone to use that? - I'd like to be able to just switch out renderer in a single location and that everything keeps on working without 
	  further modifications.
 - Port boost threads to std threads (CmThreadDefines.h)
 - Also, create all file format parsers and also make them reside in CamelotUtility
   (Actual importers will still be implemented in Editor, but parsing capabilities should be available for camelotutility)
 
 - Go to Game Engine Architecture book and make a list of Utility systems we will need (Config files, Parsers, File I/O etc)
 - Go to GEA book and read about resource managers before implementing them
   - Actually I should re-read most of the chapers in the book, or all of it

 - OpenGL non-Win32 window files haven't been properly parsed or tested
   - Since I probably can't compile them, try adding them to VS and see what intellisense says?

 - Textures and all other buffers keep a copy of their data in system memory. If there are memory constraints we might need a way to avoid this.