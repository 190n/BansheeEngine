
High-level TODO:
 - Debug tools 
   - Camera controls + world grid
 - Renderable (contains mesh/material)
 - RenderManager (iterated through Renderables and displays them on screen)
   - And its plugin implementation ForwardRenderingManager
 - Material/Pass
 - Resource loading thread safety and background loading
   - Make sure all resources have default resource that will be used before actual resource is loaded
 - Integrate with Camelot Editor
 - SceneManager plugin
   - Frustum culling and octree (or some other) acceleration structure
   - Render queue and sorting
 - DX11 render system

HIGH PRIORITY TODO:
 - I need to store material parameters somewhere as well
  - GpuProgramParams won't work because I want shader parameters to be stored independantly from the shader itself
 - GetRenderOperation doesn't consider sub-meshes
 - HLSL & Cg don't handle include files yet

Mid priority TODO:
 - Add a field that tracks % of resource deserialization in BinarySerializer

 - Separate render thread
   - CommandBuffer (technically it should be just a RenderQueue I think)
   - Main thread updates components, finds visible meshes and creates render device. At end of execution it fills up render queue
   - Render thread renders everything in the render queue, and also creates resources (although RenderQueue name doesn't make sense if its used for resources too)
   - Before I start with this I should probably strip down render system to a bare minimum

 - GpuProgram default parameters might not be needed. The parameters change with each use of the gpu program anyway
 - Mesh loading:
  - Example Freefall mesh has one index per vertex, and there are 17k+ vertices. I think I need a post-process step that optimizes them.
  - Imported FBX meshes are too big
  - Search for all remaining "TODO PORT" comments and fix them
  - How do I serialize derived classes, without rewriting all the base class serialization?
  - Ogre performed special DDS loading. I removed that. I'm not sure if I'll need to re-add it?
 - RTTI:
     When defining RTTIType like so: 
      RTTIType<D3D9HLSLProgram, HighLevelGpuProgram, D3D9HLSLProgramRTTI>
     I need to make sure that HighLevelGpuProgram class has valid RTTI type as well. Otherwise the inheritance hierarchy will not be correct. Right now this isn't checked anywhere.

Low priority TODO:
 - Mesh loading:
  - Sub-meshes aren't being transformed by world matrices of their nodes
  - FBX importer can be greatly sped up by implementing a better allocator
 - Serializable callbacks can't be null otherwise compiler complains
 - Depth test is disabled by default (OpenGL renderer at least)
 - Are resource getting properly unloaded? e.g. when shared_ptr destroys a texture is it removed from gpu?
 - Remove template from RTTIType and move it to IReflectable? This way i can hopefully move GetRTTITypeStatic and GetRTTIType to IReflectable so I don't
   need to manually implement those for every method.
 - Removed unused methods from D3D9 and GL render systems (mostly fixed function stuff)
 - Viewport needs to be updated when I call RenderTarget::setFullscreen/finishSwitchingFullscreen/updateWindowRect/windowMovedOrResized. Currently it's not
 - D3D9Texture::createTextureResources is commented out at the moment. It gets called on device reset, and at that point I should reload texture resources.
  - I should probably keep all resources by DX managed. OpenGL apparently keeps a mirror of all its resources anyway.
 - Device reset and resource re-loading in general

Optional TODO:
 - Add precompiled headers to all projects
 - If possible, make sure GLSL uses EntryPoint and Profile fields I have added to GpuProgram

 -----------------------------------------------------------------------------------------------

After everything is polished:
 - Make sure the renderer can run on a separate thread
  - Command buffers that allow dx9, dx11 and opengl all use a separate render thread
 - Load texture mips separately so we can unload HQ textures from far away objects (like UE3)
 - Get 64bit version working
 - Add Unified shader so I can easily switch between HLSL and GLSL shaders (they need same parameters usually, just different code)
    - Maybe just add support for Cg and force everyone to use that? - I'd like to be able to just switch out renderer in a single location and that everything keeps on working without 
	  further modifications.
 - Port boost threads to std threads (CmThreadDefines.h)
 
 - Go to Game Engine Architecture book and make a list of Utility systems we will need (Config files, Parsers, File I/O etc)
 - Go to GEA book and read about resource managers before implementing them
   - Actually I should re-read most of the chapers in the book, or all of it

 - OpenGL non-Win32 window files haven't been properly parsed or tested
   - Since I probably can't compile them, try adding them to VS and see what intellisense says?

 - Textures and all other buffers keep a copy of their data in system memory. If there are memory constraints we might need a way to avoid this.

