TODO
 - Ability to break external references as a pre-processing step

 ---------------------------------------
 C# component serialization

 TODO:
  - Add support for generic Lists, and potentially dictionaries
   - Be careful with current field array support, lists should probably be handled completely differently and shouldn't share that code
 - Implement set/get methods for strings/resourceRefs/gameObjectRefs/serializableObjects
 - Make SerializableObjectInfo IReflectable and create its RTTI
 - In BsScriptEnginePlugin.cpp I create RuntimeScriptObjects class but never destroy it, for debug purposes. Remember to remove that.
 - Need a class that will keep track of all instances of ScriptResource and ScriptGameObject
   - Need to update existing createInstance methods
 - Need a way to create SerializableObject - likely createInstance() method in SerializableObjectField


ScriptComponent
 - C++ half of the C# component
 - Returned from SerializableComponentInfo::createInstance and created automatically whenever a managed component is created
 - Contains a managed type-name of the component
 - Has ScriptComponentRTTI

ScriptComponentRTTI
 - Allows for easy and automatic serialization and deserialization
 - Saves managed component type-name
 - Uses RuntimeScriptObjects to get Serializable*Info, which is in turn used to find component fields
 - Has various methods returning arrays of fields
  - GetPlainFields
    - Returns FieldId -> (int, bool, byte, etc.) mapping
  - GetStringFields
    - Returns FieldId -> string mapping
  - GetSerializableObjectFields
    - Returns FieldId -> ReflectablePtr to ScriptSerializableObject (which will be serialized recursively)
  - GetGameObjectFields
    - Returns FieldId -> HGameObject
  - GetResourceFields
    - Returns FieldID -> HResource
 - Make sure to scan all base classes as well
 - When serializing all those arrays are prepared in OnSerializatioStarted
 - When deserializing they are send to the object in OnDeserializationEnded
   - However existance for the fields is first checked by getting new copy of SerializableComponentInfo and seeing
     which fields match
 - FieldId is just a name + type of the field.
 - When deserializing and component type name cannot be found, returns an empty ScriptComponent

ScriptSerializableObject
 - Has ScriptSerializableObjectRTTI
 - When deserializing and component type name cannot be found, returns null
 - Otherwise equivalent to its ScriptComponent and ScriptComponentRTTI counterpart

TO CUT DOWN ON SERIALIZATION SIZE
 - Serialize the Serializable*Info itself, and then FieldId can be just numerical ids
 - Just having the RTTI class holding a reference to Serializable*Info (and it being IReflectable) should
   ensure only one copy of it is stored.

TODO - Possibly flesh out and example with Resources or Gameobject references a bit more
 - When deserializing HResource and HGameObject handles how do I find their managed counterparts? I can create new handles
   but they could already be loaded and it doesn't make sense to have two different handles.
 - Some kind of managed <-> native mapping?

 ------------------------------------------------------
 General C# component management

 Native components like Camera
  - ScriptCamera derives from Camera
    - Then whenever I check for managed Components I need to check if object type of ScriptComponent or
	  any of the built-in types. 
	   - Checking each type might be a bit slow, but normally we will be looking for an exact type
	     so hopefully this will only matter when enumerating all components which shouldn't be during performance
		 critical moments.

TODO - When reloading scripts how to handle restoring references?
TODO - When I destroy a Component, how will I refresh the inspector to let it know that something has changed
  - Can happen from C# and C++

  -------------------------------------------------------

  Other:
  Instantiating mono generic classes: http://stackoverflow.com/questions/17628411/get-generic-type-using-mono-embedded