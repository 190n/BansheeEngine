TODO
 - Ability to break external references as a pre-processing step

 ---------------------------------------
 C# component serialization

 RuntimeScriptObjects
 - enumerateSerializable()
   - Goes through all (non-C++) Components and non-Component classes marked with [Serializable]
    - Using C++ it finds all fields in those classes. Fields and their references are stored in C++ classes.
	  - Need to enumerate value type fields, or fields holding other [Serializable] structures, references to other Components, SceneObjects or Resources
        - Plus arrays, and possibly C# List
        - Considers attributes
            - [Serialized] - Forces field to be serialized (If valid type)
            - [NotSerialized] - Forced field not to be serialized
            - By default all public members are serialized and private ones are not
	  - Something like SerializableComponentInfo (per-component), SerializableObjectInfo(per-non-component), SerializablePlainField,
	    SerializableArrayField, SerializableResourceField, SerializableGameObjectField, SerializableObjectField, etc.
 - Internally it holds a Map with name -> Serializable*Info mapping for every supported type
   - User can query if type is supported or not, and retrieve the serialization info if needed
   - Using the serialization info user can retrieve actual values from an instance easily
   - Serializable*Info classes contain findField method that accepts a name and a type
     - This is used for deserialization
 - Using Serializable*Info you can create a brand new instance of a Component or a [Serializable] non-component

ScriptComponent
 - C++ half of the C# component
 - Returned from SerializableComponentInfo::createInstance and created automatically whenever a managed component is created
 - Contains a managed type-name of the component
 - Has ScriptComponentRTTI

ScriptComponentRTTI
 - Allows for easy and automatic serialization and deserialization
 - Saves managed component type-name
 - Uses RuntimeScriptObjects to get Serializable*Info, which is in turn used to find component fields
 - Has various methods returning arrays of fields
  - GetPlainFields
    - Returns FieldId -> (int, bool, byte, etc.) mapping
  - GetStringFields
    - Returns FieldId -> string mapping
  - GetSerializableObjectFields
    - Returns FieldId -> ReflectablePtr to ScriptSerializableObject (which will be serialized recursively)
  - GetGameObjectFields
    - Returns FieldId -> HGameObject
  - GetResourceFields
    - Returns FieldID -> HResource
 - When serializing all those arrays are prepared in OnSerializatioStarted
 - When deserializing they are send to the object in OnDeserializationEnded
   - However existance for the fields is first checked by getting new copy of SerializableComponentInfo and seeing
     which fields match
 - FieldId is just a name + type of the field.
 - When deserializing and component type name cannot be found, returns an empty ScriptComponent

ScriptSerializableObject
 - Has ScriptSerializableObjectRTTI
 - When deserializing and component type name cannot be found, returns null
 - Otherwise equivalent to its ScriptComponent and ScriptComponentRTTI counterpart

TO CUT DOWN ON SERIALIZATION SIZE
 - Serialize the Serializable*Info itself, and then FieldId can be just numerical ids
 - Just having the RTTI class holding a reference to Serializable*Info (and it being IReflectable) should
   ensure only one copy of it is stored.

TODO - Possibly flesh out and example with Resources or Gameobject references a bit more
 - When deserializing HResource and HGameObject handles how do I find their managed counterparts? I can create new handles
   but they could already be loaded and it doesn't make sense to have two different handles.
 - Some kind of managed <-> native mapping?

 ------------------------------------------------------
 General C# component management

 Native components like Camera
  - ScriptCamera derives from Camera
    - Then whenever I check for managed Components I need to check if object type of ScriptComponent or
	  any of the built-in types. 
	   - Checking each type might be a bit slow, but normally we will be looking for an exact type
	     so hopefully this will only matter when enumerating all components which shouldn't be during performance
		 critical moments.

Inspector
 - RuntimeScriptObjects::enumerateInspectable creates a list of all inspectable classes (Components and others marked with [Serializable]
  - Returns a hierarchy very similar to Serializable*Info and their children (Likely re-use the same hierarchy but with different flags?)
  - This information is then used to generate needed fields

 - Importer inspectors are special and custom-built and shouldn't be considered here

TODO - When reloading scripts how to handle restoring references?
TODO - When I destroy a Component, how will I refresh the inspector to let it know that something has changed
  - Can happen from C# and C++