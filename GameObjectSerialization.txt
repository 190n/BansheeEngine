TODO
 - Ability to break external references as a pre-processing step

 ---------------------------------------

 Serialization:
 - Starts in ManagedComponent
 - in onSerializationStarted
   - I find managed class from RuntimeScriptObject
   - I query all fields of the class, and its base classes
   - I add the fields in multiple internal arrays separated by type (int, float, ComponentRef, etc.)
     - Those arrays are assigned to mRTTIData
   - Data from those arrays is retrieved using various set/get functions in the RTTI using normal RTTI functionality
     - Returned field data contains type id, field id and value
   - I will also store a list of ReflectablePtrs pointing to SerializableObjectInfo describing each used type
     - I should probably ensure that SerializableObjectInfo RTTI does not include children when serializing to prevent including useless data
   - What happens when I encounter a SerializableObject?
     - Instantiate a new instance of SerializableObject class and return a reference to it
	   - It will have SerializableObjectRTTI which will do the same job ScriptComponentRTTI (this class) does
	   - They should probably derive from same base class
 - in onSerializationEnded
   - I clear mRTTIData
 - in onDeserializationStarted
   - I create an empty set of arrays in mRTTIData
 - in onDeserializationEnded
   - TODO - Pretty much the exact reverse of above?
    - But make sure to gracefully handle non-existing types

In RuntimeScriptObjects I need to ensure I return array types when GetSerializableObjectInfo is called
 - Arrays with different ranks should count as different types?
 - Also make sure to properly deal with generic parameters
ScriptSerializableFieldInfoArray doesn't support multi-dimensional arrays (need to figure out how to look those up in Mono)
Consider removing mNamespace/mTypename from SerializableFieldInfo and adding a special SerializableFieldInfo for SerializableObjects

Dictionaries:
 - WIll need special SerializableFieldInfo for KeyValuePair

 ---------------------------------------

 Testing:
 Set up a test case - Initially disable field serialization
 - In C# create SceneObject("ManagedSO")
  - Add to it DbgComponent
 - Call a dummy C++ method (in ScriptSceneObject for example)
   - C++ method calls clone() on the scene object and creates a new "ManagedSOClone" object and parents it as a child of current SO
   - C# then retrieves a child and checks if the component is there

 ---------------------------------------
 C# component serialization

Stage 1:
 - Test if SceneObject/Component serialization works when managed components are used
   - Ignore managed component fields for now
 - Ensure non-existing types are handled

Stage 2:
 - Get managed component field serialization working
 - SerializableObjectInfoRTTI
 - Ignore arrays and collections
   - But delete existing array code as its obsolete
 - Don't ignore serializable objects

Stage 3:
 - Support for arrays & collections

Stage 4:
 - Polish: 
     - Ensure that unknown components retain their field data so when they are no longer unknown their
       data may be restored
     - Get rid of ScriptObject::createInstance and replace it with parameter in constructor
 - How to deal with components like Camera?
 - A way to serialize any object into a Resource (and deserialize it from Resource)

ARRAY/COLLECTION HANDLING
 - Encode arrays/lists/dictionaries as specialized SerializableObjects.
 - When decoding SerializableObjects I initialize SerializableObject with type name and namespace
   - In case of arrays, multi-rank arrays, lists or dictionaries it will be the same
   - createManagedInstance will instantiate a managed instance of that type
   - Internally SerializableObjectRTTI will have special handling for arrays/lists/dictionaries
     - Normally it would just query fields from RuntimeScriptObjects but now it will call: 
       - RuntimeScriptObjects::getArrayFields, RuntimeScriptObjects::getListFields, etc.
       - Dictionary entries will return special type containing two entries (or just std::pair)
       - Multi-rank arrays will return a 1D list of entries but laid out in a specific manner so we can decode them back
 - Remove my current way of handling arrays iz SerializableFieldInfo

ScriptComponent
 - C++ half of the C# component
 - Returned from SerializableComponentInfo::createInstance and created automatically whenever a managed component is created
 - Contains a managed type-name of the component
 - Has ScriptComponentRTTI

ScriptComponentRTTI
 - Allows for easy and automatic serialization and deserialization
 - Saves managed component type-name
 - Uses RuntimeScriptObjects to get Serializable*Info, which is in turn used to find component fields
 - Has various methods returning arrays of fields
  - GetPlainFields
    - Returns FieldId -> (int, bool, byte, etc.) mapping
  - GetStringFields
    - Returns FieldId -> string mapping
  - GetSerializableObjectFields
    - Returns FieldId -> ReflectablePtr to ScriptSerializableObject (which will be serialized recursively)
  - GetGameObjectFields
    - Returns FieldId -> HGameObject
  - GetResourceFields
    - Returns FieldID -> HResource
 - Make sure to scan all base classes as well
 - When serializing all those arrays are prepared in OnSerializatioStarted
 - When deserializing they are send to the object in OnDeserializationEnded
   - However existance for the fields is first checked by getting new copy of SerializableComponentInfo and seeing
     which fields match
 - FieldId is just a name + type of the field.
 - When deserializing and component type name cannot be found, returns an empty ScriptComponent

ScriptSerializableObject
 - Has ScriptSerializableObjectRTTI
 - When deserializing and component type name cannot be found, returns null
 - Otherwise equivalent to its ScriptComponent and ScriptComponentRTTI counterpart

TO CUT DOWN ON SERIALIZATION SIZE
 - Serialize the Serializable*Info itself, and then FieldId can be just numerical ids
 - Just having the RTTI class holding a reference to Serializable*Info (and it being IReflectable) should
   ensure only one copy of it is stored.

TODO - Possibly flesh out and example with Resources or Gameobject references a bit more
 - When deserializing HResource and HGameObject handles how do I find their managed counterparts? I can create new handles
   but they could already be loaded and it doesn't make sense to have two different handles.
 - Some kind of managed <-> native mapping?

 ------------------------------------------------------
 General C# component management

 Native components like Camera
  - ScriptCamera derives from Camera
    - Then whenever I check for managed Components I need to check if object type of ScriptComponent or
	  any of the built-in types. 
	   - Checking each type might be a bit slow, but normally we will be looking for an exact type
	     so hopefully this will only matter when enumerating all components which shouldn't be during performance
		 critical moments.

TODO - When reloading scripts how to handle restoring references?
TODO - When I destroy a Component, how will I refresh the inspector to let it know that something has changed
  - Can happen from C# and C++

  -------------------------------------------------------

  Other:
  Instantiating mono generic classes: http://stackoverflow.com/questions/17628411/get-generic-type-using-mono-embedded