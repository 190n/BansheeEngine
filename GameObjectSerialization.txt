TODO
 - Ability to break external references as a pre-processing step

 ---------------------------------------
 C# component serialization

Stage 1:
 - Test if SceneObject/Component serialization works when managed components are used
   - Ignore managed component fields for now
 - Ensure non-existing types are handled

Stage 2:
 - Get managed component field serialization working
 - SerializableObjectInfoRTTI
 - Ignore arrays and collections
   - But delete existing array code as its obsolete
 - Don't ignore serializable objects

Stage 3:
 - Support for arrays & collections

Stage 4:
 - Polish: 
     - Ensure that unknown components retain their field data so when they are no longer unknown their
       data may be restored
     - Get rid of ScriptObject::createInstance and replace it with parameter in constructor
 - How to deal with components like Camera?
 - A way to serialize any object into a Resource (and deserialize it from Resource)

ARRAY/COLLECTION HANDLING
 - Encode arrays/lists/dictionaries as specialized SerializableObjects.
 - When decoding SerializableObjects I initialize SerializableObject with type name and namespace
   - In case of arrays, multi-rank arrays, lists or dictionaries it will be the same
   - createManagedInstance will instantiate a managed instance of that type
   - Internally SerializableObjectRTTI will have special handling for arrays/lists/dictionaries
     - Normally it would just query fields from RuntimeScriptObjects but now it will call: 
       - RuntimeScriptObjects::getArrayFields, RuntimeScriptObjects::getListFields, etc.
       - Dictionary entries will return special type containing two entries (or just std::pair)
       - Multi-rank arrays will return a 1D list of entries but laid out in a specific manner so we can decode them back
 - Remove my current way of handling arrays iz SerializableFieldInfo

ScriptComponent
 - C++ half of the C# component
 - Returned from SerializableComponentInfo::createInstance and created automatically whenever a managed component is created
 - Contains a managed type-name of the component
 - Has ScriptComponentRTTI

ScriptComponentRTTI
 - Allows for easy and automatic serialization and deserialization
 - Saves managed component type-name
 - Uses RuntimeScriptObjects to get Serializable*Info, which is in turn used to find component fields
 - Has various methods returning arrays of fields
  - GetPlainFields
    - Returns FieldId -> (int, bool, byte, etc.) mapping
  - GetStringFields
    - Returns FieldId -> string mapping
  - GetSerializableObjectFields
    - Returns FieldId -> ReflectablePtr to ScriptSerializableObject (which will be serialized recursively)
  - GetGameObjectFields
    - Returns FieldId -> HGameObject
  - GetResourceFields
    - Returns FieldID -> HResource
 - Make sure to scan all base classes as well
 - When serializing all those arrays are prepared in OnSerializatioStarted
 - When deserializing they are send to the object in OnDeserializationEnded
   - However existance for the fields is first checked by getting new copy of SerializableComponentInfo and seeing
     which fields match
 - FieldId is just a name + type of the field.
 - When deserializing and component type name cannot be found, returns an empty ScriptComponent

ScriptSerializableObject
 - Has ScriptSerializableObjectRTTI
 - When deserializing and component type name cannot be found, returns null
 - Otherwise equivalent to its ScriptComponent and ScriptComponentRTTI counterpart

TO CUT DOWN ON SERIALIZATION SIZE
 - Serialize the Serializable*Info itself, and then FieldId can be just numerical ids
 - Just having the RTTI class holding a reference to Serializable*Info (and it being IReflectable) should
   ensure only one copy of it is stored.

TODO - Possibly flesh out and example with Resources or Gameobject references a bit more
 - When deserializing HResource and HGameObject handles how do I find their managed counterparts? I can create new handles
   but they could already be loaded and it doesn't make sense to have two different handles.
 - Some kind of managed <-> native mapping?

 ------------------------------------------------------
 General C# component management

 Native components like Camera
  - ScriptCamera derives from Camera
    - Then whenever I check for managed Components I need to check if object type of ScriptComponent or
	  any of the built-in types. 
	   - Checking each type might be a bit slow, but normally we will be looking for an exact type
	     so hopefully this will only matter when enumerating all components which shouldn't be during performance
		 critical moments.

TODO - When reloading scripts how to handle restoring references?
TODO - When I destroy a Component, how will I refresh the inspector to let it know that something has changed
  - Can happen from C# and C++

  -------------------------------------------------------

  Other:
  Instantiating mono generic classes: http://stackoverflow.com/questions/17628411/get-generic-type-using-mono-embedded