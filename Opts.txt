Make sure to also update TextSprite and ImageSprite and anything else in UpdateMesh, then don't forget to find the issue that causes elements to get marked as dirty every single frame

GpuParamBlock should be tied directly with GpuParamBlockBuffer
  - Modify material so it always sets just the first GpuParams with a specific name. This will avoid updating same buffer multiple times.

FrameAlloc
   Keeps two internal stacks
     - One core, one sim
   coreThreadBegin()
    - swaps the active stacks
   coreThreadEnd() - Must be called after Core thread has finished
    - frees the previously active stack
   During frame we call alloc()
  
 There are many allocations in CPUProfiler (especially report generation), and they aren't counted anywhere since they use
 a special allocator.

--------------------

HardwareBuffer::lock (more exactly ImmediateContext::Map) is very slow, with 35 calls taking up almost 3ms. 
 - First, mesh creates both vertex and index buffer whenever writeSubresource is called!!! It should instead just update them.
   - Never shrink mesh buffers. Add shrinkInternalBuffers property to MeshData that will force the buffers to shrink.
 - Second, mesh buffers are created with default buffer flags (static). Try changing it to dynamic
   - Allow user to specify mesh buffer type during mesh construction

When optimizing UpdateLayout make sure to mark elements that are fully culled as Culled
 - But in order to determine that I first need to update the sprite to find out the elements bounds which defeats the point
 - TODO - FIgure this out

 -------------

 Mesh
 - Change initialization so it requires number of vertices, indices and vertex description, also number of vertex streams
 - Move those required fields from MeshData into another MeshDesc structure that is used for initialization
 - During initialization also provide STATIC or DYNAMIC flags
 - writeSubresource
  - add size and offset fields in MeshData which tell the method where exactly to write data and how much data is used
    - also determines which part of the buffer is rendered
    - throw exception if mesh data offset/size go over the limit of the buffer
  - add "discardEntireBuffer" flag
   - ensure buffer is compatible with the flag (I think it needs to be dynamic)
 - allocateSubresourceBuffer used for reading must not be broken by these changes
 - Don't forget to update mesh RTTI
 - Implement VertexDataDesc and use it during Mesh initialization, and also internally in MeshData

Texture
 - Texture already works the way mesh should

TransientMesh
 - Only used for writing, only dynamic, and only MAP_NO_OVERWRITE writing
 - Accepts starting buffer sizes, and will enlarge them as needed
  - When buffer is enlarged send a warning so user knows to use a bigger buffer next time
 - Keeps track of parts of the buffer used by GPU using GPU queries

----------

OT: When setting buffers I should modify RenderSystem::setVertexBuffer so it can accept multiple buffers. So when mesh is bound all its streams can be bound in one call.

BIG TODO FINALLY: Reorganize GUI so it all uses one big vertex buffer (probably in the form of a TransientMesh). This means I need better support for drawing individual objects
from a transient mesh by drawing only parts of its buffer. But only do this after I have optimized and tested the normal mesh (on all render systems)

---------

Immediate implementation issues:
MeshData with 0 submeshes should be assumed to have one sub-mesh that covers the entire buffer. I need to take that into consideration when writing to resource.

Places that use MeshData:
DrawHelper2D, DrawHelper3D - 5 methods each
GUIManager::updateMeshes
DockManager:updateDropOverlay
FBXImporter::parseMesh

Fix how I handle sub-meshes
 - right now they are read on sim thread, but set on core thread which is wrong

 Don't forget to add vert/index offsets to meshData