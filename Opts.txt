Make sure to also update TextSprite and ImageSprite and anything else in UpdateMesh, then don't forget to find the issue that causes elements to get marked as dirty every single frame

GpuParamBlock should be tied directly with GpuParamBlockBuffer
  - Modify material so it always sets just the first GpuParams with a specific name. This will avoid updating same buffer multiple times.

FrameAlloc
   Keeps two internal stacks
     - One core, one sim
   coreThreadBegin()
    - swaps the active stacks
   coreThreadEnd() - Must be called after Core thread has finished
    - frees the previously active stack
   During frame we call alloc()
  
 There are many allocations in CPUProfiler (especially report generation), and they aren't counted anywhere since they use
 a special allocator.

--------------------

When optimizing UpdateLayout make sure to mark elements that are fully culled as Culled
 - But in order to determine that I first need to update the sprite to find out the elements bounds which defeats the point
 - TODO - FIgure this out

 -------------

 Mesh
  - Make sure to check DX9 and OpenGL performance when new buffers are implemented

TransientMesh
 - Only used for writing, only dynamic, and only MAP_NO_OVERWRITE writing
 - Accepts starting buffer sizes, and will enlarge them as needed
  - When buffer is enlarged send a warning so user knows to use a bigger buffer next time
 - Keeps track of parts of the buffer used by GPU using GPU queries

----------

BIG TODO FINALLY: Reorganize GUI so it all uses one big vertex buffer (probably in the form of a TransientMesh). This means I need better support for drawing individual objects
from a transient mesh by drawing only parts of its buffer. But only do this after I have optimized and tested the normal mesh (on all render systems)

---------

Other possible improvements:
 - MeshData always completely overwrites destination mesh sub-meshes, plus it doesn't allow empty spaces or overlapping between the sub-meshes, they are always
   sequential.
 - Textures do lock/unlock when writing data to them. This causes an unnecessary copy in DX11 (and possibly other APIs)
   - add writeData/readData methods that do those things as efficiently as possible
 - Textures always create dynamic buffers
 - When writing to mesh vertex buffer that requires a color flip I need to create a temporary copy of the entire buffer. It would be better to handle this differently. 