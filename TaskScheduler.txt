TaskManager (or JobScheduler)
 - Ensure it only uses 6 threads. Two should be reserved for sim and core thread.
    - Potentially a separate ThreadPool class?
 - Support for task dependencies
 - Support for task priorities
 - Callable from multiple threads
 - When task is queued a Task object is returned (can be copied)
   - You may use that for chaining dependencies
   - For waiting on a task
 - HOW DO I CHECK WHEN TASKS ARE COMPLETE?
   - Check AsyncOp and use that same approach. In fact maybe use AsyncOp itself within the Task

 - Ability for threads to wait() until task is complete. And while waiting to complete tasks themselves.
  - Only main threads can wait (core and sim threads)
  - When they wait they will actually stop, and the task scheduler will start a new thread to run tasks in their place
    - Once the task they are waiting for is done, the new thread is returned to thread pool
  - When calling wait() and starting a new thread, first check if any active thread is being shut-down and if so, cancel the shutdown instead of creating a new thread

 - Tasks should have names (later for visualization and profiling purposes)


ThreadPool
 - NEVER start threads manually. Only use ThreadPool.
 - This way I can initialize stack allocators and profiler threads just one for the started threads and don't have to worry about user forgetting how to do that.


LATER - Profiler should be able to visualize tasks

------------------

Non-task-scheduler:

Module does need to be fixed for multi-threading. If it is created on one thread and used on another, a race condition could occurr. But do I use modules on two different threads?
 - I will with Debug, and probably others
 - Making the shutdown/destroy variables atomic should be enough