DockManager implementation plan:
 - DockManager main class
   - When empty make sure it has a GUIElement that covers its entire space so it can catch and drop events. Will likely need a special transparent GUIElement?
   - Has a reference to one DockContainer, which is initially empty
      - DockContainer can have two DockContainer children, or one EditorWidgetContainer child (maybe make a container base class? - optional)
	  - DockContainer should probably contain a GUIElement which can receieve events
	     - This would mean extending GUIManager so it can send events to top level elements, and if they don't process them, send them one level lower?
	  - Resizing a DockContainer resizes all child DockContainers recursively (and EditorWidgetContainers)
	  - If DockContainer has DockContainer children then it also contains a  GUIElement resizer (just an empty space, in the direction of the split)
	    - Moving the element allows you to resize the two child DockContainers
 - When last element is removed from EditorWidgetContainer make sure to notify the parent
 - Make main render window frameless
   - Implement MainEditorWindow from EditorWindowBase
   - Make sure MainEditorWindow holds a DockManager reference and resizes it with the window

DockContainer biggest issues:
 - How do I draw the drag and drop overlay??
 - How do I detect mouse input yet still let it through to child widget

FIRST CREATE DOCK CONTAINER WITHOUT DRAG AND DROP SUPPORT

RenderTexture issues:
 Fix up GUI render texture so it isn't transparent
 Rename waitUntilInitialized to synchronize()
 Set up a GUIViewport element which sets up a camera so it renders to that part of the window

 DirectX 9 currently DOES NOT support bindable render textures:
  - Bindable render textures should be created using CreateTexture and D3DUSAGE_RENDERTARGET/D3DUSAGE_DEPTHSTENCIL
   - UNLESS render target is using antialiasing, in which case it cannot be bound and should be created as it
    - However if it cannot be bound I should warn the user (in RenderTexture::getBindable* methods)

Make sure to test everything thoroughly - right now I have tested very little
Drag and drop manager currently ignores the provided icon, but it should use it as a cursor

Prevent docking if available size is less than 20 pixels, otherwise there might be some weirdness

------------------------

Other things to remember:
 - Possibly add a way to have hidden widgets in the EditorWidgetContainer (like side-bars that pop on mouse over in Visual Studio)
 - A way to persist window states
 - Also a way to reset all widgets to original locations

------------------------

Some use cases:
 1. User drags one of the tabs on EditorWindow and then drops it
  - If user drags for N pixels the draged tab (and its EditorWidget) is removed from the EditorWindow and added to DragAndDropManager
  - If user drops the window onto empty/unsupported element drag and drop manager "dropCallback" is executed and EditorWidget is restored in its own EditorWindow.
  - If user drags the window over a title bar, drop positions get highlighted on the title bar
    - If the user releases over the title bar, the window is added at the specified drop position
  - If the user drags over an EditorWidget content area, semi-transparent drop areas are shown, and current area is highlighted
    - Dropping the window in that area will split the available space between existng and new window contents

 2. User organizes his windows and the quits and restarts the program
  - TODO