DockManager
 - DOCKING: When user drags a window, EditorWidgetContainer detects that and reacts accordingly
   - For title bar it draws the drop locations, and does the same for content
   - After the drop is done it just notifies the DockManager (if the drop was on contents) with addWidgetRelativeToMe(this, location, draggedWidget)
      - (If the drop was done on the title bar, then the EditorWidgetContainer can handle that internally)
	  - Drop manager creates two new DockedWindowContainers
	   - Existing a new widgets are moved into each. Existing container (for the existing widget) now becomes the parent of the two new containers.
	   - Size of the new containers are adjusted (and containers internally adjust the size of their widgets, and/or their child containers)
	  - A spacer widget is added between them, that may be used for resizing. DockedWindowContainers on both sides of the spacer and kept as a reference
   - Also, make sure to detect a case when there are no widgets in the dock manager
   - Resizing a DockedWindowContainer recursivelly resizes all child containers
 - UNDOCKING: If the last EditorWidget is removed from EditorWidgetContainer, DockManager is notified and it takes care of removing the relevant
   DockedWindowContainer and the spacer.

TODO - Possibly add a way to have hidden widgets in the EditorWidgetContainer (like side-bars that pop on mouse over in Visual Studio)
TODO - A way to persist window states
  - Also a way to reset all widgets to original locations

------------------------

DockManager implementation plan:
 - DockManager main class
   - When empty make sure it has a GUIElement that covers its entire space so it can catch and drop events. Will likely need a special transparent GUIElement?
   - Has a reference to one DockContainer, which is initially empty
      - DockContainer can have two DockContainer children, or one EditorWidgetContainer child (maybe make a container base class? - optional)
	  - DockContainer should probably contain a GUIElement which can receieve events
	     - This would mean extending GUIManager so it can send events to top level elements, and if they don't process them, send them one level lower?
	  - Resizing a DockContainer resizes all child DockContainers recursively (and EditorWidgetContainers)
	  - If DockContainer has DockContainer children then it also contains a  GUIElement resizer (just an empty space, in the direction of the split)
	    - Moving the element allows you to resize the two child DockContainers
 - When last element is removed from EditorWidgetContainer make sure to notify the parent
 - Make main render window frameless
   - Implement MainEditorWindow from EditorWindowBase
   - Make sure MainEditorWindow holds a DockManager reference and resizes it with the window

DockContainer biggest issues:
 - How do I draw the drag and drop overlay??
 - How do I detect mouse input yet still let it through to child widget

FIRST CREATE DOCK CONTAINER WITHOUT DRAG AND DROP SUPPORT

Make sure to test everything thoroughly - right now I have tested very little
Drag and drop manager currently ignores the provided icon, but it should use it as a cursor

TODO - Prevent docking if available size is less than 20 pixels, otherwise there might be some weirdness

------------------------

Some use cases:
 1. User drags one of the tabs on EditorWindow and then drops it
  - If user drags for N pixels the draged tab (and its EditorWidget) is removed from the EditorWindow and added to DragAndDropManager
  - If user drops the window onto empty/unsupported element drag and drop manager "dropCallback" is executed and EditorWidget is restored in its own EditorWindow.
  - If user drags the window over a title bar, drop positions get highlighted on the title bar
    - If the user releases over the title bar, the window is added at the specified drop position
  - If the user drags over an EditorWidget content area, semi-transparent drop areas are shown, and current area is highlighted
    - Dropping the window in that area will split the available space between existng and new window contents

 2. User organizes his windows and the quits and restarts the program
  - TODO