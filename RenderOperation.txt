Since DrawHelper needs to queue render commands together with scene objects (in order for transparency to work okay), I will need to implement the RenderOperation approach I thought about earlier.
 Rename current RenderOperation to SubMeshData
 Real render operations contains SubMeshData + layer (can be filtered per-camera) + queue (each mesh has a queue and another queue by camera) + Pass
 (Remove Camera->rendersSceneObjects and replace it with layer)
 (Make sure to set up preset queues, like opaque, transparent, etc)

 Then I can hook up GUIManager, OverlayManager and DrawHelper with a callback that is used by Renderer to retrieve their operations
 Attempt to move all sorting (including by render target) out of forward renderer and into an overridable sorter class
  - Create a hash list with key(containing type, queue, layer, etc.) used for sorting

  Add "materialGroup" to material. It can be used for sorting similar materials together, instead of using some automatic way of determining it.

  Issues with my render operation system:
 Sorting by depth is impossible because I don't provide any position info with my RenderOperation

 For each frame I will need to calculate world bounds and world position. I cannot do it each time I retrieve a RenderOperation so it should be cached somewhere and reused throughout the frame.
 - Unity keeps it with Renderable
   - What happens when the Mesh resource is updated?
 - How do I do it for non-renerables though?

 ---------------------

 RenderOpSorter:
 - (Before we send RenderOps to the sorter we first filter them by camera)
 - Accepts parameters whether to sort back-to-front, front-to-back or ignore depth (depth ignored with skybox and overlay)
 - Another parameter is whether to sort by pass (transparent ops can't be sorted by pass)
 - Then we sort:
  - If back to front
    - We sort by depth and that's it. We could also sort by material by that only makes sense if two elements have exact same depth which will almost never happen
  - If front to back
    - Sort by material first. We call materialSimilarity() method which returns lesser value depending how similar two materials are. We do a pass over all unsorted materials and if similarity is below some threshold we add it to the current bucket. If there are no more similar materials we create a new bucket.
    - Within bucket we sort by similarity as well (as the elements are added)
    - Then finally we sort the buckets by depth front to back
  - No depth
   - Same as front to back, without the depth sort

 - Sorter should operate directly on provided render op array