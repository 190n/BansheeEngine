Classes that need C# wrappers:
Math (Instead of a wrapper create actual C# classes, but which map 1-1 with C++ code so we can move them through C++/C# boundaries):
 -Vector2
 -Vector3
 -Vector4
 -Matrix3
 -Matrix4
 -Quaternion
 -Rect
 -Int2
 -Color

Resources:
 - Mesh
 - Texture
 - Font
 - Material
  - GpuProgram
  - Technique
  - Shader
  - DepthStencil/Blend/Rasterizer/Sampler state

Core objects:
 - RenderTarget
  - RenderWindow
  - RenderTexture
  - MultiRenderTexture
 - SceneObject
 - Component
  - plus specific components Camera, Renderable, maybe others
  - (later ofc ability to derive custom C# components)

GUI:
 - EditorWindow
 - GUIWidget
 - GUILabel/GUIButton/GUIToggle/GUIInputBox/GUITexture...
 - GUILayoutX/GUILayoutY/GUILayoutOptions
 - GUISkin/GUIElementStyle

Systems:
 - Resources
 - Importer
 - Application (startUp/shutDown)
 - Cursor
 - Debug
 - Input
 - Time

 -----------------

 ScriptManager
 - loadAssembly
 - compileAssembly

ScriptAssembly
 - GetClass(namespace, name)

ScriptClass
 - GetField(name)
 - GetMethod(name)
 - InvokeMethod(name, void** params)
 - AddInternalCall
 - CreateInstance()

ScriptMethod
 - Invoke(void** params)

 retval = mono_jit_exec (domain, assembly, argc - 1, argv + 1);
to call a Main function in the assembly

 -----------------

 add BansheeEditor class
 Add C++ EditorApplication and have it start up Application and create a main window
Then in C# class just call EditorApplication to create a main window

Create another .exe class called BansheeEd, which loads up MBansheeEditor assembly and calls EditorApplication to start everything up.
 - I might need to add Mono loading code to BansheeEngine first?
 - ScriptManager
  - InvokeMethod

For EditorWindow, add a new class in BansheeEditor, which pretty much does the job of  EditorWidget::open
 - Except it creates an empty widget. (It will also create a window, but in C++ code)
 - All the window docking/undocking moving/resizing is done in C++
 - EditorWindow only has a reference to EditorWidget

 -----------------

 Implementation steps:
 - Get EditorApplication finished and make the main window open from C#
   - (Will possibly need to make new CamelotClient.cpp? since that one is full of junk)
 - Add support for Resources
   - Importer - Likely invisible for outside world
   - Resources.Save/Load - Will likely need some kind of an AssetManager for all imported assets
   - Texture, Mesh, Font, Shader, Material
     - Before this I will also probably require all the basic classes like Vector3, etc.
 - Emulate current CamelotClient tests in C#

 -----------------

 But which ones will I need initially?
  - [EditorApplication] - Entry point. Creates a MainEditorWindow
  - [EditorWindow] (Scene, Project, Hierarchy, etc.)
   - show()/hide()
  - [MainEditorWindow]
   - Slight variation of EditorWindow as there can be only one of them
   - Contains [TitleBar], [DockManager]
  - When adding GUI elements I need to make it easy to add game GUI elements,
    but also make a distinction and make it possible to add editor GUI elements.
	- Each EditorWindow contains a [GUIWidget] (created by default)
	  - This GUIWIdget is created specially with EditorWindow as its target
	- GUIWidget is also a Component which can be used for rendering to Game view
	  - All game GUIWidgets are created with Game render target as their target
  - [GameObject], [Component]
    - Need something to add GUIWidget to
  - I need to have [Application] running within EditorApplication
    - So when I remove EditorApplication everything runs as normal
	- How to make the distinction?
	  - Application needs to render to RenderTarget when in editor, and have its own window when standalone
	   - When in Editor, EditorApplication will call application and tell it to create a render target
	   - When published I will have a Game class, which will also call Application and run it in a window
	  - Certain components should only exists in editor (Like Scene camera, gizmos and etc.)
	   - Add a flag to GameObjects like in Unity, that can hide the object in Hierarchy, or make it not save
	   - Editor objects would be hidden and would not save with the level, which would make publishing work
  - GUIWidget
    - [GUILayoutX], [GUILayoutY], [GUIArea], [GUISpace], [GUIFlexibleSpace]
	- [GUIElement]
	  - [GUILabel], [GUIButton], etc.
	- TODO: GUISkin? - Will I need to create interface for textures and resource loading/importing as well? Probably
  
  ----------------

  I want my .exe to be native. Internally it will call MBansheeEngine and MBansheeEditor.

This will allow me to debug and start C++ as usual.

 -----------------

 Notes:
  - I will need RequireComponent[] attribute. This attribute should automatically add the specified class to the wanted
    GameObject. This is useful if you suddenly decide your class is now dependant on another, but you would otherwise have to manually
	go through all instances of that GameObject in scene and add the required component.
	  - HOWEVER, a more generic way of doing this (maybe using prefabs) would be useful. Because what happens when a class suddenly becomes
	    dependant on a resource, or a specific instance of a class? In that case we cannot use RequireComponent.
  - Use FrameUpdate[QueueIdx], OnCreate[QueueIdx], OnDestroy[QueueIdx] attributes to signify to the scripting system when to execute
    certain methods. QueueIdx allows you to specify the order in which these methods will be called. In Unity you have Awake and Start methods
	for initialization, but here you may just specify OnCreate[0] and OnCreate[1].
	  - I will likely need C++ equivalents of these queues because C++ components will also require such ordering. 