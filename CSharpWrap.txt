Classes that need C# wrappers:
Math (Instead of a wrapper create actual C# classes, but which map 1-1 with C++ code so we can move them through C++/C# boundaries):
 -Vector2
 -Vector3
 -Vector4
 -Matrix3
 -Matrix4
 -Quaternion
 -Rect
 -Int2
 -Color

Resources:
 - Mesh
 - Texture
 - Font
 - Material
  - GpuProgram
  - Technique
  - Shader
  - DepthStencil/Blend/Rasterizer/Sampler state

Core objects:
 - RenderTarget
  - RenderWindow
  - RenderTexture
  - MultiRenderTexture
 - SceneObject
 - Component
  - plus specific components Camera, Renderable, maybe others
  - (later ofc ability to derive custom C# components)

GUI:
 - EditorWindow
 - GUIWidget
 - GUILabel/GUIButton/GUIToggle/GUIInputBox/GUITexture...
 - GUILayoutX/GUILayoutY/GUILayoutOptions
 - GUISkin/GUIElementStyle

Systems:
 - Resources
 - Importer
 - Application (startUp/shutDown)
 - Cursor
 - Debug
 - Input
 - Time


 -----------------

 Notes:
  - I will need RequireComponent[] attribute. This attribute should automatically add the specified class to the wanted
    GameObject. This is useful if you suddenly decide your class is now dependant on another, but you would otherwise have to manually
	go through all instances of that GameObject in scene and add the required component.
	  - HOWEVER, a more generic way of doing this (maybe using prefabs) would be useful. Because what happens when a class suddenly becomes
	    dependant on a resource, or a specific instance of a class? In that case we cannot use RequireComponent.
  - Use FrameUpdate[QueueIdx], OnCreate[QueueIdx], OnDestroy[QueueIdx] attributes to signify to the scripting system when to execute
    certain methods. QueueIdx allows you to specify the order in which these methods will be called. In Unity you have Awake and Start methods
	for initialization, but here you may just specify OnCreate[0] and OnCreate[1].
	  - I will likely need C++ equivalents of these queues because C++ components will also require such ordering. 