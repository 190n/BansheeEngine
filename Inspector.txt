Needed controls:
Array field/List field/Dictionary field
Matrix3 field
Matrix4 field
GameObject field
Resource field

-------------
Cursor
 - A way to save/load a set of cursors

 IMMEDIATE:
  - Deleting first entry in input field moves the cursor incorrectly
  - Test if parsing int/float value from int/float field actually works
  - ProfilerOverlay elements are constantly dirty? even though I'm not calling update

Other:
 - Refactor BuiltinMaterialFactory to BuiltinEngineResources

-------------

REFACTOR c++ GUI a bit:
 - Add new graphic for input boxes and add object field graphics
 - Add "padding" to GUIElementStyle and make sure GUILayout (and whatever else) uses it
 - Edit all Editor *Field classes and make sure they use GUILayout internally (where possible, probably not for Foldout which has a background element that would require 2 layers)


How will I add editor fields to GUILayout? Right now I have a bunch of Add* methods and that won't work for Editor-only fields. I could extend GUILayout to EditorGUILayout but then GUIArea needs to be aware of that as well...

GUIElement has GetChild/GetNumChildren, which isn't really useful for elements like GUIToggle, GUIButton, etc.
 - GUIElements and GUILayout should still share same base class, but make it GUIElementBase, that doesn't include children

Refactor GUILayout so it has AddElement, RemoveElement, InsertElement, GetChildren, GetNumChildren methods
 - GUIElement reference should be kept by parent layout, so if it is ever removed (or never added) it will get garbage collected and destroyed

Layouts/Areas/Elements need SetVisible(true/false) toggle

-------------
Implementation order:
 - Component foldout
 - Color picker modular window
   - Possibly a generic ModularWindow class
   - EditorUtility::showColorPicker
 - GameObject/resource field
 - Matrix fields
 - Refactor C# GUI
 - Basic InspectableObject and basic Inspector that open Inspector window, display SceneManager base fields and a list of components
 - Per-component generic and custom inspectors

-------------
IMPORTANT:
 - I should probably consider making each Component part of the inspector its own separate GUIWidget, otherwise I wont
   be able to use multiple GUIAreas in the Inspectors, which is fairly limiting.
     - Each has a separate EditorGUI instance?


TOMORROW:
 - InspectableObject calls a C++ method which gets all SerializableFields, and C++ in turn
   generates a list of InspectableFields
     - They should have a type, name, and get/set methods

Dont forget to implement SceneObject.GetComponents

Tab indexes
 - EditorFields should have SetNextField method that allow you to set tab order directly
 - InspectableField are automatically assigned ID
   - ID is part depth (also governs identation) and part sequential index
   - This allows me to add/remove elements from objects like lists and arrays and not mess up the tab order
   - Also collapse/expand doesn't require us to modify tab indexes
   - InspectableObjects should likely have a reference to the Inspector so that they can query next InspectableField based on tab ID
   - These IDs are then used for calling SetNextField on normal EditorFields

Custom inspector
 - Custom inspector should have complete knowledge of the GUI objects within it (so that parent Inspector can expand/collapse it without worrying about the user forgetting to hide an element and messing up the other inspectors)
 - Since custom inspector should have all of its elements in a specific GUILayout, we should be able to just manipulate that GUILayout

Positioning/Indentation
 - Inspector needs to be provided with a layout
 - Whenever an InspectableObject is created it will create a new X layout with a space (for indenting) and a Y layout (for child elements)
   - We will provide it with parent layout from which to create those on
   - And depth for determining indent amount
   - For top level objects there is no space or X layout (depth is 0)
  - InspectableFields will use the Layouts they are given by their parent InspectableObjects

C++ bit for creating InspectableField
 - Need a way to list all fields in an object (should already have most of that functionality)
 - And hook up those fields with get/set callbacks for editing/updating

UndoRedo
 - A global UndoRedo class for generic use
 - Specific UndoRedo for automatic use in InspectableField
 - Will likely need Undo/Redo context
    - e.g. when in a text field I want to undo/redo my changes in that text field one by one
    - but when I click outside maybe I just want to undo to the previous state before I even focused on that text field
      - plus it doesn't make sense for example to undo a text field if I'm currently focusing on something in scene

IMPLEMENTATION
 - Add a Foldout GUI type and its C# version
 - Attempt to display a list of Components on a SceneObject just by using the foldouts

 - Add basic IntField and hook it up with InspectableField (get/set methods and everything)

 - Add Multi-rank array, List & Dictionary types