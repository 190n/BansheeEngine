Needed controls:
Array field/List field/Dictionary field
Matrix3 field
Matrix4 field
GameObject field
Resource field

-------------
Cursor
 - A way to save/load a set of cursors

 IMMEDIATE:
  - Deleting first entry in input field moves the cursor incorrectly
  - Test if parsing int/float value from int/float field actually works
  - ProfilerOverlay elements are constantly dirty? even though I'm not calling update

Other:
 - Refactor BuiltinMaterialFactory to BuiltinEngineResources

-------------

Boost any replacement: http://www.codeproject.com/Articles/11250/High-Performance-Dynamic-Typing-in-C-using-a-Repla

-------------

Get rid of the CamelotFramework namespace
 - I shouldn't need to prefix each variable with CM::

Fix C# interface to GUI elements

REFACTOR c++ GUI a bit:
 - GameObjectField
   - When dragging over GameObjectField cursor needs to change depending whether drop will be accepted or not
   - How will I limit it to just certain component types?

Make a common class for ScriptGUIElement as they all share:
 - Destroy(), DestroyInstance(), SetParent(), SetVisible() methods, and potentially others

Add InsertElement to GUILayout

-------------
Implementation order:
 - Component foldout
 - Color picker modular window
   - Possibly a generic ModularWindow class
   - EditorUtility::showColorPicker
 - GameObject/resource field
 - Matrix fields
 - Refactor C# GUI
 - Basic InspectableObject and basic Inspector that open Inspector window, display SceneManager base fields and a list of components
 - Per-component generic and custom inspectors

-------------
IMPORTANT:
 - I should probably consider making each Component part of the inspector its own separate GUIWidget, otherwise I wont
   be able to use multiple GUIAreas in the Inspectors, which is fairly limiting.
     - Each has a separate EditorGUI instance?


TOMORROW:
 - InspectableObject calls a C++ method which gets all SerializableFields, and C++ in turn
   generates a list of InspectableFields
     - They should have a type, name, and get/set methods

Dont forget to implement SceneObject.GetComponents

Tab indexes
 - EditorFields should have SetNextField method that allow you to set tab order directly
 - InspectableField are automatically assigned ID
   - ID is part depth (also governs identation) and part sequential index
   - This allows me to add/remove elements from objects like lists and arrays and not mess up the tab order
   - Also collapse/expand doesn't require us to modify tab indexes
   - InspectableObjects should likely have a reference to the Inspector so that they can query next InspectableField based on tab ID
   - These IDs are then used for calling SetNextField on normal EditorFields

Custom inspector
 - Custom inspector should have complete knowledge of the GUI objects within it (so that parent Inspector can expand/collapse it without worrying about the user forgetting to hide an element and messing up the other inspectors)
 - Since custom inspector should have all of its elements in a specific GUILayout, we should be able to just manipulate that GUILayout

Positioning/Indentation
 - Inspector needs to be provided with a layout
 - Whenever an InspectableObject is created it will create a new X layout with a space (for indenting) and a Y layout (for child elements)
   - We will provide it with parent layout from which to create those on
   - And depth for determining indent amount
   - For top level objects there is no space or X layout (depth is 0)
  - InspectableFields will use the Layouts they are given by their parent InspectableObjects

C++ bit for creating InspectableField
 - Need a way to list all fields in an object (should already have most of that functionality)
 - And hook up those fields with get/set callbacks for editing/updating

UndoRedo
 - A global UndoRedo class for generic use
 - Specific UndoRedo for automatic use in InspectableField
 - Will likely need Undo/Redo context
    - e.g. when in a text field I want to undo/redo my changes in that text field one by one
    - but when I click outside maybe I just want to undo to the previous state before I even focused on that text field
      - plus it doesn't make sense for example to undo a text field if I'm currently focusing on something in scene

IMPLEMENTATION
 - Add a Foldout GUI type and its C# version
 - Attempt to display a list of Components on a SceneObject just by using the foldouts

 - Add basic IntField and hook it up with InspectableField (get/set methods and everything)

 - Add Multi-rank array, List & Dictionary types